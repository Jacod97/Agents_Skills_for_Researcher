---
name: research-advisor
description: >
  연구자가 연구 아이디어나 주제를 제시했을 때, 정보 충분성 판별부터 기술적 타당성 분석,
  난이도 산정, 아키텍처 설계까지 전체 흐름을 오케스트레이션하는 메인 스킬.
  "이 연구 가능할까?", "이 아이디어 실현 가능해?", "연구 주제 분석해줘",
  "이 프로젝트 타당성 검토해줘" 등의 요청 시 트리거된다.
user-invocable: true
argument-hint: "[연구 아이디어 또는 주제]"
metadata:
  author: skills_for_researcher
  version: "2.0"
  language: ko
  role: orchestrator
---

# Research Advisor — 씬 오케스트레이터

이 스킬은 **흐름 제어와 데이터 전달만** 담당합니다.
각 단계의 세부 절차, 질의 방식, 출력 형식은 해당 스킬 자체의 SKILL.md 명세를 따릅니다.
오케스트레이터가 하위 스킬의 절차를 재정의하거나 출력 형식을 축소하지 마세요.

---

## 실행 흐름

```
Step 1  research-intake         정보 수집 & 구조화
          │
          ▼
Step 2  feasibility-check       타당성 검증 (서브 에이전트)
          │
          ├─ 불가 → 사용자에게 결과 전달 → 종료
          ├─ 조건부 → 사용자에게 조건 설명 → 진행 여부 확인
          │
          ▼
Step 3  skill-profiler           사용자 기술 역량 파악 (메인 스레드)
     +  stack-analyzer           필요 기술 스택 분석 (서브 에이전트, 백그라운드)
          │
          ▼
Step 4  difficulty-scorer        난이도 산정 + 학습 권장
          │
          ▼
Step 5  architecture-designer    아키텍처 공동 설계 (사용자 확인 후)
```

---

## Step 1: 정보 수집 — research-intake

**목적**: 후속 분석에 필요한 충분한 맥락을 확보합니다.

**실행**: research-intake 스킬의 명세에 따라 실행합니다.
- 사용자의 `$ARGUMENTS`를 초기 입력으로 전달
- 정보 충분성 판별, 부족 시 플랜 모드 질의, 구조화 결과 확정까지 모두 research-intake가 수행

**데이터 계약**:
- 입력: 사용자의 아이디어 원문 (`$ARGUMENTS`)
- 출력: `구조화_결과` — 7개 정보 축이 정리된 테이블 (research-intake의 Phase 3 출력 형식)

**다음 단계 조건**: 사용자가 구조화 결과를 확인("맞습니다")하면 Step 2로 진행.

---

## Step 2: 타당성 검증 — feasibility-check (서브 에이전트)

**목적**: 아이디어가 현존하는 기술로 실현 가능한지 판단합니다.

**실행**: Task 도구로 서브 에이전트를 생성합니다.

```
Task 도구 호출:
  subagent_type: general-purpose
  prompt: |
    당신은 feasibility-check 스킬입니다.
    아래 연구 아이디어의 기술적 타당성을 분석해주세요.
    feasibility-check SKILL.md에 정의된 분석 절차(1~3단계)와 출력 형식을
    그대로 따라 결과를 반환하세요.

    === 연구 아이디어 구조화 결과 ===
    [Step 1의 구조화_결과 전체를 여기에 삽입]
```

**핵심 규칙**: 출력 형식을 별도로 지정하지 않습니다. feasibility-check/SKILL.md의 "출력 형식" 섹션이 정의한 전체 구조(기술 요소 분석 테이블, 유사 연구 사례 + 출처, 리스크 완화 방안, 대안 섹션 포함)를 서브 에이전트가 스스로 따르도록 합니다.

**데이터 계약**:
- 입력: `구조화_결과` (Step 1 출력)
- 출력: `타당성_결과` — 판정(✅/⚠️/❌), 기술 요소 분석, 유사 사례, 필요 기술 영역, 리스크, 대안

**분기 처리**:

| 판정 | 오케스트레이터 행동 |
|------|-------------------|
| ❌ 구현 불가 | `타당성_결과`를 사용자에게 그대로 보여주고, 대안 섹션을 강조한 뒤 **종료** |
| ⚠️ 조건부 가능 | `타당성_결과`를 사용자에게 보여주고, AskUserQuestion으로 진행 여부 확인. "진행" 시 Step 3 |
| ✅ 구현 가능 | `타당성_결과`를 사용자에게 보여주고 Step 3으로 진행 |

---

## Step 3: 병렬 분석 — skill-profiler + stack-analyzer

**목적**: 사용자의 보유 기술과 프로젝트의 필요 기술을 동시에 파악합니다.

### 3-A: skill-profiler (메인 스레드)

**실행**: skill-profiler 스킬의 명세에 따라 실행합니다.
- `구조화_결과`를 전달하여 연구 주제의 핵심 도메인 개념 기반으로 질의
- 범용 기술(pandas, Git 등)이 아닌, 연구 도메인 핵심 개념과 방법론에 대해 질의

**데이터 계약**:
- 입력: `구조화_결과` (Step 1 출력 — 도메인 맞춤 질문 설계에 사용)
- 출력: `사용자_기술_프로필` — skill-profiler의 "출력 형식" 섹션에 정의된 전체 구조

### 3-B: stack-analyzer (서브 에이전트, 백그라운드)

**실행**: 3-A **시작과 동시에** Task 도구로 서브 에이전트를 백그라운드 생성합니다.

```
Task 도구 호출:
  subagent_type: general-purpose
  run_in_background: true
  prompt: |
    당신은 stack-analyzer 스킬입니다.
    아래 연구 프로젝트에 필요한 기술 스택을 분석해주세요.
    stack-analyzer SKILL.md에 정의된 분석 절차(1~3단계)와 출력 형식을
    그대로 따라 결과를 반환하세요.

    === 연구 아이디어 구조화 결과 ===
    [Step 1의 구조화_결과 전체를 여기에 삽입]

    === 타당성 분석에서 도출된 필요 기술 영역 ===
    [Step 2 타당성_결과의 "필요 기술 영역" 섹션을 여기에 삽입]
```

**핵심 규칙**: 출력 형식을 별도로 지정하지 않습니다. stack-analyzer/SKILL.md의 "출력 형식" 섹션이 정의한 전체 구조(단계별 테이블, 통합 스택 요약, 의존 관계, 컴퓨팅 자원 표 포함)를 서브 에이전트가 스스로 따르도록 합니다.

**합류**: 3-A(skill-profiler) 완료 후 TaskOutput으로 3-B 결과를 수집합니다.

**데이터 계약**:
- 입력: `구조화_결과` + `타당성_결과`의 필요 기술 영역
- 출력: `필요_기술_스택` — stack-analyzer의 "출력 형식" 섹션에 정의된 전체 구조

---

## Step 4: 난이도 산정 — difficulty-scorer

**목적**: 보유 기술과 필요 기술을 대조하여 정량적 난이도를 산출하고 학습을 권장합니다.

**실행**: difficulty-scorer 스킬의 명세에 따라 실행합니다.
- 채점 절차(1~3단계), 출력 형식 모두 difficulty-scorer가 자체 정의한 대로 수행

**데이터 전달**: difficulty-scorer에게 아래 두 데이터를 입력으로 명시적으로 전달합니다.

```
이전 단계에서 수집된 데이터를 기반으로 difficulty-scorer 스킬 명세에 따라
난이도를 산정하고 학습을 권장해주세요.

=== 사용자 기술 프로필 (skill-profiler 출력) ===
[Step 3-A의 사용자_기술_프로필 전체를 여기에 삽입]

=== 필요 기술 스택 (stack-analyzer 출력) ===
[Step 3-B의 필요_기술_스택 전체를 여기에 삽입]
```

**데이터 계약**:
- 입력: `사용자_기술_프로필` (Step 3-A) + `필요_기술_스택` (Step 3-B)
- 출력: `난이도_결과` — 종합 점수, 강점/부족 서술, 학습 권장 (서술형)

**사용자 전달**: `난이도_결과`를 사용자에게 그대로 보여줍니다.

---

## Step 5: 아키텍처 설계 — architecture-designer

**목적**: 연구 시스템의 아키텍처를 사용자와 대화하며 설계합니다.

**진입 조건**: AskUserQuestion으로 사용자에게 아키텍처 설계를 진행할지 확인합니다.
- "진행" → architecture-designer 스킬의 명세에 따라 실행
- "건너뛰기" → 최종 요약으로 이동

**실행**: architecture-designer 스킬의 명세에 따라 실행합니다.
- Phase A~E의 대화형 설계 절차 모두 architecture-designer가 자체 정의한 대로 수행

**데이터 전달**: 이전 단계의 결과를 맥락으로 제공합니다.

```
이전 분석 결과를 참고하여 architecture-designer 스킬 명세에 따라
아키텍처 설계를 진행해주세요.

=== 연구 아이디어 구조화 결과 ===
[구조화_결과 요약]

=== 확정된 기술 스택 ===
[필요_기술_스택의 통합 스택 요약 섹션]
```

---

## 최종 요약

모든 Step 완료 후 (또는 Step 5를 건너뛴 경우) 아래 요약을 생성합니다.
이 요약은 이전 단계들의 출력을 **인용**하여 구성합니다 (재분석하지 않음):

```
## 기술 타당성 분석 최종 요약

**연구 주제**: [구조화_결과에서 인용]

| 항목 | 결과 |
|------|------|
| 기술적 타당성 | [타당성_결과의 판정 인용] |
| 구현 난이도 | [난이도_결과의 종합 점수 인용] |
| 핵심 기술 스택 | [필요_기술_스택의 통합 요약 인용] |
| 최대 리스크 | [타당성_결과의 주요 리스크 인용] |
| 핵심 학습 필요 | [난이도_결과의 🔴 항목 인용] |

**다음 단계 권장 액션**:
1. [난이도_결과의 핵심 학습 권장에서 가장 우선순위 높은 항목]
2. [구조화_결과의 데이터 확보 관련 액션]
3. [아키텍처 설계 결과가 있으면 해당 다음 단계]
```

---

## 오케스트레이터 원칙

1. **세부 절차 재정의 금지**: 각 스킬의 분석 절차, 질의 방식, 출력 형식을 오케스트레이터에서 다시 쓰지 않는다
2. **출력 형식 축소 금지**: 서브 에이전트 프롬프트에서 스킬 명세보다 간소화된 출력을 요구하지 않는다
3. **데이터 전달만 담당**: 이전 Step의 출력을 다음 Step에 전달할 때, 원문을 그대로 전달한다
4. **분기 로직만 판단**: 타당성 판정(✅/⚠️/❌), 사용자 확인(진행/건너뛰기) 등 흐름 분기만 처리한다
5. **결과 인용만**: 최종 요약에서 이전 출력을 재분석하지 않고 인용한다
